<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<style>
  body {
    margin: 0;
    background-color: #202020;
  }

  canvas {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 2px solid #272727;
    background-color: #0000ee10;
  }

  .lowerRight {
    margin: 2px;
    font-family: serif;
    font-size: large;
    color: red;
    position: fixed;
    right: 0;
    bottom: 0;
  }
</style>

<body>
  <canvas id="canvas"></canvas>
  <canvas id="canvas2"></canvas>
  <img src="moon.png" alt="" id="moon" style="visibility: hidden;" />
  <script>
    /*
    Johan Karlsson, DonKarlssonSan
  */

    // class Particle {
    //   constructor(x, y, size) {
    //     this.speed = 0.6;
    //     this.x = x;
    //     this.y = y;
    //     this.vx = (Math.random() - 0.5) * this.speed;
    //     this.vy = (Math.random() - 0.5) * this.speed;
    //     this.opacity = 1;
    //     this.size = size;
    //   }

    //   draw (context) {
    //     this.opacity -= this.speed / 200;
    //     context.fillStyle = this.color();
    //     context.fillRect(this.x, this.y, this.size, this.size);
    //   }

    //   move () {
    //     this.x += this.vx;
    //     // y speed is influenced by "gravity"
    //     this.y += this.vy + (1 - this.opacity) * this.speed;
    //   }

    //   color () {
    //     return "rgba(255, 0, 0, " + this.opacity + ")";
    //   }
    // }

    class Laser {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.steps = [];
        this.particles = [];
      }

      // drawTo (x, y, ctx) {
      //   // 开始一个新的路径。
      //   ctx.beginPath();
      //   // 将路径的起点移动到当前激光的起始位置。
      //   ctx.moveTo(this.x, this.y);
      //   // 从起点绘制一条直线到指定的坐标 (x, y)。
      //   ctx.lineTo(x, y);
      //   // 绘制路径，即绘制激光的线条。
      //   ctx.stroke();
      //   ctx.fillStyle = "red";
      //   // 在指定的坐标 (x, y) 处绘制一个填充为红色的矩形，大小为 5x5 像素。
      //   ctx.fillRect(x, y, 5, 5);
      // }

      // TODO:
      // drawEnd (ctx) {
      //   var p = this.steps.shift();
      //   if (p !== undefined) {
      //     this.drawTo(p[0], p[1], ctx);
      //   } else {
      //     var index = this.particles.length;
      //     // Loop through backwards so we can remove
      //     // particles from the array inside the loop.
      //     while (index--) {
      //       var p = this.particles[index];
      //       p.move();
      //       if (p.opacity < 0 || p.x < 0 ||
      //         p.x > this.w || p.y < 0 || p.y > this.h) {
      //         this.particles.splice(index, 1);
      //       } else {
      //         p.draw(ctx);
      //       }
      //     }
      //   }
      // }

      // TODO:
      // endFrom (x0, y0) {
      //   var nrOfSteps = 800;
      //   var i = nrOfSteps;
      //   while (i--) {
      //     var x = this.x + i * (x0 - this.x) / nrOfSteps + Math.cos(i / 10) * i / 4;
      //     var y = this.y + i * (y0 - this.y) / nrOfSteps + Math.sin(i / 10) * i / 4;
      //     this.steps.push([x, y]);
      //     if (i < 100) {
      //       this.particles.push(new Particle(this.x, this.y, 2));
      //     }
      //   }
      // }
    }

    class LaserWriter {
      constructor(canvasId, canvas2Id) {
        // The first canvas holds the text being drawn (static).
        var canvas = document.getElementById(canvasId);
        this.ctx = canvas.getContext("2d");

        //  The second canvas holds the laser beam and particles
        //  (animated).
        var canvas2 = document.getElementById(canvas2Id);
        this.ctx2 = canvas2.getContext("2d");
        this.w = canvas.width = canvas2.width = 900;
        this.h = canvas.height = canvas2.height = 500;

        this.tick = 0;
        this.pointsIndex = 0;
        this.points = [];
        this.particles = [];
        // All the points that make up the whole word
        this.size = 3; // ? 为森么是3
        this.startX = 0;
        this.laserStart = { x: 300, y: 50 };
        this.x = 0;
        this.y = 0;
      }

      init (text, size) {
        this.ctx.font = size + "px serif";
        // Draw black text on the canvas temporarily

        // 计算文本在画布上的起始位置，使其居中显示。
        this.startX = (this.w - this.ctx.measureText(text).width * 3) * 0.5;
        var moon = document.getElementById("moon");
        // this.ctx.fillText(text, 1, 100);
        var width = 500;
        var height = 300;
        this.ctx.drawImage(moon, 0, 0, width, width);
        var image = this.ctx.getImageData(0, 0, width, height);
        console.log('image', image);
        globalThis.xxxx = image;
        // 将像素数据转换为 32 位无符号整数数组。
        // 以32位无符号整数的形式查看原始的像素数据。这样做的好处是，你可以一次处理一个像素的所有颜色分量，而不是分别处理每个颜色分量。
        // 每个元素代表一个像素，每个像素的红色、绿色、蓝色和透明度值都包含在这个32位的整数中。具体来说，最低的8位表示红色值，接下来的8位表示绿色值，再接下来的8位表示蓝色值，最高的8位表示透明度值。
        // 436207616
        var buffer32 = new Uint32Array(image.data.buffer);
        // globalThis.buffer32 = buffer32;
        for (var x = 0; x < width; x++) {
          for (var y = 0; y < height; y++) {
            // The buffer is linear, y*w+x is a trick
            // to calculate the linear index.

            // 检查当前像素是否存在（非透明）。
            if (buffer32[y * width + x]) {
              // There is a pixel here, add a point
              // console.log('[x, y]', [x, y]);
              this.points.push([x, y]);
            }
          }
        } // 一行一行的放
        console.log('this.points', this.points);
        // Clear the text once, we will just be adding
        // to this canvas from now on (no clearing).
        this.ctx.clearRect(0, 0, this.w, this.h);
        this.ctx.fillStyle = "rgba(255, 0, 0, 0.34)";

        // For the laser
        this.ctx2.strokeStyle = "rgba(200, 0, 70, 1)";
        this.ctx2.lineCap = "round";
        this.ctx2.lineWidth = 4;

        // this.laser = new Laser(this.laserStart.x, this.laserStart.y);
      }

      draw () {
        this.ctx2.clearRect(0, 0, this.w, this.h);

        // Continue drawing text?
        if (this.pointsIndex < this.points.length) {
          // Ok, we are not done 

          // Draw the text, one point at a time
          var p = this.points[this.pointsIndex];
          this.x = p[0] * this.size + this.startX;
          this.y = p[1] * this.size + 80;
          // 不理解 p[x,y] -> [x,y]
          // 计算点在画布上的实际坐标
          this.drawPointAt(this.x, this.y);

          // 绘制激光效果，从上一个点到当前点。
          // this.laser.drawTo(this.x, this.y, this.ctx2);

          // Just add a particle every other tick
          // 粒子效果
          // if (this.tick % 2 === 0) {
          //   var particle = new Particle(this.x, this.y, this.size);
          //   this.particles.push(particle);
          // }
          // } else if (this.pointsIndex === this.points.length) {
          // this.laser.endFrom(this.x, this.y);
          // } else {
          // this.laser.drawEnd(this.ctx2);
        }

        // 光⚡️， blilbli 的效果
        // this.drawParticles();

        this.pointsIndex++;
        this.tick++;

        // Keep the animation going a while after we have
        // drawn all the text to let the last particles
        // fall off the screen and the laser end animation
        // run.
        // 慢慢绘制
        if (this.pointsIndex < this.points.length + 10000) {
          // Draw three steps (ticks) then redraw screen
          if (this.tick % 3 === 0) {
            requestAnimationFrame(() => this.draw());
          } else {
            this.draw();
          }
        }
      }

      drawPointAt (x, y) {
        this.ctx.beginPath();
        this.ctx.arc(x, y, this.size * 2, 0, Math.PI * 2, false);
        this.ctx.fill();
      }

      // drawParticles () {
      //   var index = this.particles.length;
      //   // Loop through backwards so we can remove
      //   // particles from the array inside the loop.
      //   while (index--) {
      //     var p = this.particles[index];
      //     p.move();
      //     if (p.opacity < 0 || p.x < 0 ||
      //       p.x > this.w || p.y < 0 || p.y > this.h) {
      //       this.particles.splice(index, 1);
      //     } else {
      //       p.draw(this.ctx2);
      //     }
      //   }
      // }
    }

    var laserWriter = new LaserWriter("canvas", "canvas2");
    laserWriter.init("2023!", 100);
    laserWriter.draw();

  </script>
</body>

</html>